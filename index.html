<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>capsules by btj</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-light.css">
    <meta name="viewport" content="width=device-width">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>capsules</h1>
        <p>A static encapsulation checker and doclet for multi-package Java modules</p>

        <p class="view"><a href="https://github.com/btj/capsules/releases/download/v1.3/capsules-1.3.zip">Download</a></p>
        <p class="view"><a href="https://github.com/btj/capsules">View the Project on GitHub</a></p>
      </header>
      <section>
        <p>Modular software development implies a <strong>distinction between interface and implementation</strong>. Java supports treating classes and packages as modules through its access modifiers. However, Java lacks such support for multi-package modules.</p>

<p>This project defines a <strong>convention</strong> for identifying multi-package modules in the form of <em>capsules</em>. A capsule is defined by a <em>root package</em> and an <em>export keyword</em>. An export keyword is an annotation type. A capsule consists of its root package and all descendant packages in the package tree. The <em>exported elements</em> of a capsule are the types and members in the capsule that are annotated with the capsule's export keyword. A root package is associated with an export keyword using the @capsules.Capsule annotation.</p>

<p>The project offers <strong>tool support</strong> for capsules in the form of a static checker and a Javadoc doclet.</p>

<p>The <strong>static checker</strong>, given a set of .class files, checks that they respect capsule encapsulation, i.e. that all code not in a capsule accesses only the capsule's exported types and members.</p>

<p>The <strong>doclet</strong> generates Javadoc documentation for a given capsule, including only its exported types and members.</p>

<h2>
<a id="example" class="anchor" href="#example" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Example</h2>

<p>Consider a module consisting of the packages <code>foo</code> and <code>foo.bar</code>, and some client code in <code>fooclient</code>:</p>

<div class="highlight highlight-source-java"><pre><span class="pl-c">// foo/Foo.java</span>
<span class="pl-k">package</span> <span class="pl-smi">foo</span>;

@<span class="pl-smi">FooAPI</span>
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Foo</span> {

    <span class="pl-k">@FooAPI</span>
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">void</span> <span class="pl-en">apiMethod</span>() {}

    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">void</span> <span class="pl-en">internalMethod</span>() {
        <span class="pl-smi">foo.bar<span class="pl-k">.</span>Bar</span><span class="pl-k">.</span>internalMethod(); <span class="pl-c">// OK</span>
    }

}</pre></div>

<div class="highlight highlight-source-java"><pre><span class="pl-c">// foo/FooAPI.java</span>
<span class="pl-k">package</span> <span class="pl-smi">foo</span>;

@<span class="pl-smi">java.lang.annotation<span class="pl-k">.</span>Documented</span>
@<span class="pl-smi">FooAPI</span>
<span class="pl-k">public</span> <span class="pl-k">@interface</span> <span class="pl-en">FooAPI</span> {}</pre></div>

<div class="highlight highlight-source-java"><pre><span class="pl-c">// foo/package-info.java</span>
@<span class="pl-smi">capsules<span class="pl-k">.</span>Capsule</span>(exportKeyword<span class="pl-k">=</span><span class="pl-smi">FooAPI</span><span class="pl-k">.</span>class)
<span class="pl-k">package</span> <span class="pl-smi">foo</span>;</pre></div>

<div class="highlight highlight-source-java"><pre><span class="pl-c">// foo/bar/Bar.java</span>
<span class="pl-k">package</span> <span class="pl-smi">foo.bar</span>;

@<span class="pl-smi">foo<span class="pl-k">.</span>FooAPI</span>
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Bar</span> {

    <span class="pl-k">@foo</span><span class="pl-k">.</span><span class="pl-smi">FooAPI</span>
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">void</span> <span class="pl-en">apiMethod</span>() {}

    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">void</span> <span class="pl-en">internalMethod</span>() {
        <span class="pl-smi">foo<span class="pl-k">.</span>Foo</span><span class="pl-k">.</span>internalMethod(); <span class="pl-c">// OK</span>
    }

}</pre></div>

<div class="highlight highlight-source-java"><pre><span class="pl-c">// fooclient/FooClient.java</span>
<span class="pl-k">package</span> <span class="pl-smi">fooclient</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">FooClient</span> {

    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">void</span> <span class="pl-en">main</span>(<span class="pl-k">String</span>[] <span class="pl-v">args</span>) {
        <span class="pl-smi">foo<span class="pl-k">.</span>Foo</span><span class="pl-k">.</span>apiMethod(); <span class="pl-c">// OK</span>
        <span class="pl-smi">foo<span class="pl-k">.</span>Foo</span><span class="pl-k">.</span>internalMethod(); <span class="pl-c">// Not OK</span>
        <span class="pl-smi">foo.bar<span class="pl-k">.</span>Bar</span><span class="pl-k">.</span>apiMethod(); <span class="pl-c">// OK</span>
        <span class="pl-smi">foo.bar<span class="pl-k">.</span>Bar</span><span class="pl-k">.</span>internalMethod(); <span class="pl-c">// Not OK</span>
    }

}</pre></div>

<p>Method <code>foo.Foo.internalMethod</code> is used within the module by <code>foo.bar.Bar.internalMethod</code> but is not supposed to be accessed by client code. Similarly, method <code>foo.bar.Bar.internalMethod</code> is used within the module by <code>foo.Foo.internalMethod</code> but is not supposed to be accessed by client code.</p>

<p>We can indicate that package <code>foo</code> and its subpackages form a module by applying the <code>@Capsule</code> annotation to package <code>foo</code>. Furthermore, to indicate which types and members are supposed to be used by client code and which are not, we define an annotation type <code>FooAPI</code> and we annotate all types and members that we want to export with it. We indicate that <code>FooAPI</code> serves as the export keyword for the capsule using the <code>@Capsule</code> annotation's <code>exportKeyword</code> element.</p>

<p>We can now use the static checker to check that client code uses only exported elements. Since the checker operates on .class files, we first need to compile the codebase:</p>

<pre><code>javac -g -classpath capsules.jar -d bin -sourcepath src src/fooclient/*.java src/foo/*.java src/foo/bar/*.java
</code></pre>

<p>Note: be sure to include the <code>-g</code> flag so that the checker can report the source locations of the errors it finds.</p>

<p>Now we can run the checker, passing the directory with the .class file tree as an argument:</p>

<pre><code>java -jar capsules.jar bin
</code></pre>

<p>It will produce the following output:</p>

<pre><code>(fooclient/FooClient.java:7): Method not exported by capsule foo
(fooclient/FooClient.java:9): Method not exported by capsule foo
2 errors found
</code></pre>

<p>We can generate Javadoc documentation for the exported elements of our capsule using the following command line:</p>

<pre><code>javadoc -docletpath capsules.jar -doclet capsules.doclet.Doclet -d foodocs
    -classpath capsules.jar -sourcepath src -subpackages foo -exportKeyword foo.FooAPI
</code></pre>

<h2>
<a id="friends-and-multi-root-capsules" class="anchor" href="#friends-and-multi-root-capsules" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Friends and multi-root capsules</h2>

<p>A capsule may optionally specify a list of friend packages. For example:</p>

<div class="highlight highlight-source-java"><pre>@<span class="pl-smi">capsules<span class="pl-k">.</span>Capsule</span>(exportKeyword<span class="pl-k">=</span><span class="pl-smi">SystemAPI</span><span class="pl-k">.</span>class, friends<span class="pl-k">=</span>{<span class="pl-s"><span class="pl-pds">"</span>org.friend1<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>org.friend2<span class="pl-pds">"</span></span>})
<span class="pl-k">package</span> <span class="pl-smi">org.system</span>;</pre></div>

<p>The effect is that code in the friend packages and their subpackages gets unrestricted access to the capsule.</p>

<p>This feature can be used to more easily use the capsules toolkit on an existing codebase where the code for the capsule is not below a single root package. Proceed as follows:</p>

<ol>
<li>Declare each root package as a capsule separately</li>
<li>Use the same export keyword for all capsules</li>
<li>Make each capsule a friend of the other capsules</li>
</ol>

<p>For example:</p>

<div class="highlight highlight-source-java"><pre><span class="pl-c">// org/root1/package-info.java</span>
@<span class="pl-smi">capsules<span class="pl-k">.</span>Capsule</span>(exportKeyword<span class="pl-k">=</span><span class="pl-smi">org.root1<span class="pl-k">.</span>SystemAPI</span><span class="pl-k">.</span>class, friends<span class="pl-k">=</span>{<span class="pl-s"><span class="pl-pds">"</span>org.root2<span class="pl-pds">"</span></span>})
<span class="pl-k">package</span> <span class="pl-smi">org.root1</span>;</pre></div>

<div class="highlight highlight-source-java"><pre><span class="pl-c">// org/root2/package-info.java</span>
@<span class="pl-smi">capsules<span class="pl-k">.</span>Capsule</span>(exportKeyword<span class="pl-k">=</span><span class="pl-smi">org.root1<span class="pl-k">.</span>SystemAPI</span><span class="pl-k">.</span>class, friends<span class="pl-k">=</span>{<span class="pl-s"><span class="pl-pds">"</span>org.root1<span class="pl-pds">"</span></span>})
<span class="pl-k">package</span> <span class="pl-smi">org.root2</span>;</pre></div>

<p>This way, org.root1 and org.root2 effectively constitute a single capsule.</p>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/btj">btj</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>
