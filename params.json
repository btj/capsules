{"name":"capsules","tagline":"A static encapsulation checker and doclet for multi-package Java modules","body":"Modular software development implies a **distinction between interface and implementation**. Java supports treating classes and packages as modules through its access modifiers. However, Java lacks such support for multi-package modules.\r\n\r\nThis project defines a **convention** for identifying multi-package modules in the form of _capsules_. A capsule is defined by a _root package_ and an _export keyword_. An export keyword is an annotation type. A capsule consists of its root package and all descendant packages in the package tree. The _exported elements_ of a capsule are the types and members in the capsule that are annotated with the capsule's export keyword. A root package is associated with an export keyword using the @capsules.Capsule annotation.\r\n\r\nThe project offers **tool support** for capsules in the form of a static checker and a Javadoc doclet.\r\n\r\nThe **static checker**, given a set of .class files, checks that they respect capsule encapsulation, i.e. that all code not in a capsule accesses only the capsule's exported types and members.\r\n\r\nThe **doclet** generates Javadoc documentation for a given capsule, including only its exported types and members.\r\n\r\n## Example ##\r\n\r\nConsider a module consisting of the packages `foo` and `foo.bar`, and some client code in `fooclient`:\r\n\r\n```java\r\n// foo/Foo.java\r\npackage foo;\r\n\r\n@FooAPI\r\npublic class Foo {\r\n\r\n    @FooAPI\r\n    public static void apiMethod() {}\r\n\r\n    public static void internalMethod() {\r\n        foo.bar.Bar.internalMethod(); // OK\r\n    }\r\n\r\n}\r\n```\r\n\r\n```java\r\n// foo/FooAPI.java\r\npackage foo;\r\n\r\n@java.lang.annotation.Documented\r\n@FooAPI\r\npublic @interface FooAPI {}\r\n```\r\n\r\n```java\r\n// foo/package-info.java\r\n@capsules.Capsule(exportKeyword=FooAPI.class)\r\npackage foo;\r\n```\r\n\r\n```java\r\n// foo/bar/Bar.java\r\npackage foo.bar;\r\n\r\n@foo.FooAPI\r\npublic class Bar {\r\n\r\n    @foo.FooAPI\r\n    public static void apiMethod() {}\r\n\r\n    public static void internalMethod() {\r\n        foo.Foo.internalMethod(); // OK\r\n    }\r\n\r\n}\r\n```\r\n\r\n```java\r\n// fooclient/FooClient.java\r\npackage fooclient;\r\n\r\npublic class FooClient {\r\n\r\n    public static void main(String[] args) {\r\n        foo.Foo.apiMethod(); // OK\r\n        foo.Foo.internalMethod(); // Not OK\r\n        foo.bar.Bar.apiMethod(); // OK\r\n        foo.bar.Bar.internalMethod(); // Not OK\r\n    }\r\n\r\n}\r\n```\r\n\r\nMethod `foo.Foo.internalMethod` is used within the module by `foo.bar.Bar.internalMethod` but is not supposed to be accessed by client code. Similarly, method `foo.bar.Bar.internalMethod` is used within the module by `foo.Foo.internalMethod` but is not supposed to be accessed by client code.\r\n\r\nWe can indicate that package `foo` and its subpackages form a module by applying the `@Capsule` annotation to package `foo`. Furthermore, to indicate which types and members are supposed to be used by client code and which are not, we define an annotation type `FooAPI` and we annotate all types and members that we want to export with it. We indicate that `FooAPI` serves as the export keyword for the capsule using the `@Capsule` annotation's `exportKeyword` element.\r\n\r\nWe can now use the static checker to check that client code uses only exported elements. Since the checker operates on .class files, we first need to compile the codebase:\r\n\r\n```\r\njavac -g -classpath capsules.jar -d bin -sourcepath src src/fooclient/*.java src/foo/*.java src/foo/bar/*.java\r\n```\r\nNote: be sure to include the `-g` flag so that the checker can report the source locations of the errors it finds.\r\n\r\nNow we can run the checker, passing the directory with the .class file tree as an argument:\r\n\r\n```\r\njava -jar capsules.jar bin\r\n```\r\n\r\nIt will produce the following output:\r\n```\r\n(fooclient/FooClient.java:7): Method not exported by capsule foo\r\n(fooclient/FooClient.java:9): Method not exported by capsule foo\r\n2 errors found\r\n```\r\n\r\nWe can generate Javadoc documentation for the exported elements of our capsule using the following command line:\r\n\r\n```\r\njavadoc -docletpath capsules.jar -doclet capsules.doclet.Doclet -d foodocs\r\n    -classpath capsules.jar -sourcepath src -subpackages foo -exportKeyword foo.FooAPI\r\n```\r\n\r\n## Friends and multi-root capsules ##\r\n\r\nA capsule may optionally specify a list of friend packages. For example:\r\n\r\n```java\r\n@capsules.Capsule(exportKeyword=SystemAPI.class, friends={\"org.friend1\", \"org.friend2\"})\r\npackage org.system;\r\n```\r\n\r\nThe effect is that code in the friend packages and their subpackages gets unrestricted access to the capsule.\r\n\r\nThis feature can be used to more easily use the capsules toolkit on an existing codebase where the code for the capsule is not below a single root package. Proceed as follows:\r\n  1. Declare each root package as a capsule separately\r\n  1. Use the same export keyword for all capsules\r\n  1. Make each capsule a friend of the other capsules\r\n\r\nFor example:\r\n```java\r\n// org/root1/package-info.java\r\n@capsules.Capsule(exportKeyword=org.root1.SystemAPI.class, friends={\"org.root2\"})\r\npackage org.root1;\r\n```\r\n\r\n```java\r\n// org/root2/package-info.java\r\n@capsules.Capsule(exportKeyword=org.root1.SystemAPI.class, friends={\"org.root1\"})\r\npackage org.root2;\r\n```\r\n\r\nThis way, org.root1 and org.root2 effectively constitute a single capsule.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}